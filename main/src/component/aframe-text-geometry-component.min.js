(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  require('../index.js');
  
  },{"../index.js":2}],2:[function(require,module,exports){
  /**
   * TextGeometry component for A-Frame.
   */
  require('./lib/FontLoader')
  require('./lib/TextGeometry')
  
  var debug = AFRAME.utils.debug;
  
  var error = debug('aframe-text-component:error');
  
  var fontLoader = new THREE.FontLoader();
  
  AFRAME.registerComponent('text-geometry', {
    schema: {
      bevelEnabled: {default: false},
      bevelSize: {default: 8, min: 0},
      bevelThickness: {default: 12, min: 0},
      curveSegments: {default: 12, min: 0},
      font: {type: 'asset', default: 'https://rawgit.com/ngokevin/kframe/master/components/text-geometry/lib/helvetiker_regular.typeface.json'},
      height: {default: 0.05, min: 0},
      size: {default: 0.5, min: 0},
      style: {default: 'normal', oneOf: ['normal', 'italics']},
      weight: {default: 'normal', oneOf: ['normal', 'bold']},
      value: {default: ''}
    },
  
    /**
     * Called when component is attached and when component data changes.
     * Generally modifies the entity based on the data.
     */
    update: function (oldData) {
      var data = this.data;
      var el = this.el;
  
      var mesh = el.getOrCreateObject3D('mesh', THREE.Mesh);
      if (data.font.constructor === String) {
        // Load typeface.json font.
        fontLoader.load(data.font, function (response) {
          var textData = AFRAME.utils.clone(data);
          textData.font = response;
          mesh.geometry = new THREE.TextGeometry(data.value, textData);
        });
      } else if (data.font.constructor === Object) {
        // Set font if already have a typeface.json through setAttribute.
        mesh.geometry = new THREE.TextGeometry(data.value, data);
      } else {
        error('Must provide `font` (typeface.json) or `fontPath` (string) to text component.');
      }
    }
  });
  
  },{"./lib/FontLoader":3,"./lib/TextGeometry":4}],3:[function(require,module,exports){
  /* From: https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js
     with alternatons from ESM-style exports to CommonJS-style.
  
  The MIT License
  
  Copyright © 2010-2023 three.js authors
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  
  const {
    FileLoader,
    Loader,
    ShapePath
  } = THREE;
  
  class FontLoader extends Loader {
  
    constructor( manager ) {
  
      super( manager );
  
    }
  
    load( url, onLoad, onProgress, onError ) {
  
      const scope = this;
  
      const loader = new FileLoader( this.manager );
      loader.setPath( this.path );
      loader.setRequestHeader( this.requestHeader );
      loader.setWithCredentials( this.withCredentials );
      loader.load( url, function ( text ) {
  
        const font = scope.parse( JSON.parse( text ) );
  
        if ( onLoad ) onLoad( font );
  
      }, onProgress, onError );
  
    }
  
    parse( json ) {
  
      return new Font( json );
  
    }
  
  }
  
  //
  
  class Font {
  
    constructor( data ) {
  
      this.isFont = true;
  
      this.type = 'Font';
  
      this.data = data;
  
    }
  
    generateShapes( text, size = 100 ) {
  
      const shapes = [];
      const paths = createPaths( text, size, this.data );
  
      for ( let p = 0, pl = paths.length; p < pl; p ++ ) {
  
        shapes.push( ...paths[ p ].toShapes() );
  
      }
  
      return shapes;
  
    }
  
  }
  
  function createPaths( text, size, data ) {
  
    const chars = Array.from( text );
    const scale = size / data.resolution;
    const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
  
    const paths = [];
  
    let offsetX = 0, offsetY = 0;
  
    for ( let i = 0; i < chars.length; i ++ ) {
  
      const char = chars[ i ];
  
      if ( char === '\n' ) {
  
        offsetX = 0;
        offsetY -= line_height;
  
      } else {
  
        const ret = createPath( char, scale, offsetX, offsetY, data );
        offsetX += ret.offsetX;
        paths.push( ret.path );
  
      }
  
    }
  
    return paths;
  
  }
  
  function createPath( char, scale, offsetX, offsetY, data ) {
  
    const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];
  
    if ( ! glyph ) {
  
      console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );
  
      return;
  
    }
  
    const path = new ShapePath();
  
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  
    if ( glyph.o ) {
  
      const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
  
      for ( let i = 0, l = outline.length; i < l; ) {
  
        const action = outline[ i ++ ];
  
        switch ( action ) {
  
          case 'm': // moveTo
  
            x = outline[ i ++ ] * scale + offsetX;
            y = outline[ i ++ ] * scale + offsetY;
  
            path.moveTo( x, y );
  
            break;
  
          case 'l': // lineTo
  
            x = outline[ i ++ ] * scale + offsetX;
            y = outline[ i ++ ] * scale + offsetY;
  
            path.lineTo( x, y );
  
            break;
  
          case 'q': // quadraticCurveTo
  
            cpx = outline[ i ++ ] * scale + offsetX;
            cpy = outline[ i ++ ] * scale + offsetY;
            cpx1 = outline[ i ++ ] * scale + offsetX;
            cpy1 = outline[ i ++ ] * scale + offsetY;
  
            path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
  
            break;
  
          case 'b': // bezierCurveTo
  
            cpx = outline[ i ++ ] * scale + offsetX;
            cpy = outline[ i ++ ] * scale + offsetY;
            cpx1 = outline[ i ++ ] * scale + offsetX;
            cpy1 = outline[ i ++ ] * scale + offsetY;
            cpx2 = outline[ i ++ ] * scale + offsetX;
            cpy2 = outline[ i ++ ] * scale + offsetY;
  
            path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
  
            break;
  
        }
  
      }
  
    }
  
    return { offsetX: glyph.ha * scale, path: path };
  
  }
  
  THREE.FontLoader = FontLoader;
  },{}],4:[function(require,module,exports){
  /* From: https://github.com/mrdoob/three.js/blob/master/examples/jsm/geometries/TextGeometry.js
     with alternatons from ESM-style exports to CommonJS-style.
  
  The MIT License
  
  Copyright © 2010-2023 three.js authors
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  
  /**
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
   *  bevelOffset: <float> // how far from text outline does bevel start
   * }
   */
  
  const {
    ExtrudeGeometry
  } = THREE;
  
  class TextGeometry extends ExtrudeGeometry {
  
    constructor( text, parameters = {} ) {
  
      const font = parameters.font;
  
      if ( font === undefined ) {
  
        super(); // generate default extrude geometry
  
      } else {
  
        const shapes = font.generateShapes( text, parameters.size );
  
        // translate parameters to ExtrudeGeometry API
  
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
  
        // defaults
  
        if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
        if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
        if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
  
        super( shapes, parameters );
  
      }
  
      this.type = 'TextGeometry';
  
    }
  
  }
  
  
  THREE.TextGeometry = TextGeometry;
  },{}]},{},[1]);